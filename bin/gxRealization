#! /usr/bin/env python

# Code: gxRealization
# Version: 1
# Version changes: GENERATE KDE FROM FIXED POPULATION TO MONTE CARLO 
#                  A GALACTIC REALIZATION OF THE POPULATION ACCORDING 
#                  TO FLAGS SET BY USER
#
# Edited on:  13 FEB 2018


##############################################################################
#  IMPORT ALL NECESSARY PYTHON PACKAGES
##############################################################################
from collections import OrderedDict
import warnings
import argparse
import ConfigParser

import math
import random
import time
from time import sleep
import string
import os.path

import numpy as np
import scipy.special as ss
import scipy.stats as stats
import pandas as pd
import multiprocessing as mp
import matplotlib.pyplot as plt

import aCOSMIC.MC_samp as MC_sample 
import aCOSMIC.GW_calcs as GW_calcs
import aCOSMIC.utils as utils
##################################################################################
# DEFINE COMMANDLINE ARGUMENTS
##################################################################################
def parse_commandline():
    """Parse the arguments given on the command-line.
    """
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--galaxy_component", help="Galaxy Components. Options include Bulge ThinDisk and ThickDisk", required=True)
    parser.add_argument("--dist_model", help="Galaxy distribution model. fiducial is McMillan (2010)", required=True, default='McMillan')
    parser.add_argument("--final_kstar1", help="Specify the final condition of kstar1, you want systems to end at for your samples", required=True, type=float, nargs='+')
    parser.add_argument("--final_kstar2", help="Specify the final condition of kstar2, you want systems to end at for your samples", required=True, type=float, nargs='+')
    parser.add_argument("--N_realizations", help="Number of Galactic realziations to sample", type=int, default=100)
    parser.add_argument("-n", "--nproc", help="number of processors", type=int, default=1)
    parser.add_argument("--gx_save", help="Save the galaxy realizations; MAY GENERATE LARGE DATA SETS", default=True)
    parser.add_argument("--HG_save", help="Save systems which undergo common envelope w/ HG star secondary", default=False)
    parser.add_argument("--LISA_calc", help="Save the SNR and PSD of the population in the LISA band", default=True)
    parser.add_argument("--verbose", action="store_true", default=False, help="Run in Verbose Mode")
    args = parser.parse_args()

    if len(args.final_kstar1) > 2 or len(args.final_kstar2) > 2:
        raise parser.error('final kstar1 and final kstar2 '
                           'must be either a single value or '
                           'a range between two values.')

    if (len(args.final_kstar1) == 2):
        if (args.final_kstar1[0] >= args.final_kstar1[1]):
            raise parser.error('Range provided for kstar1 invalid')

    if (len(args.final_kstar2) == 2):
        if (args.final_kstar2[0] >= args.final_kstar2[1]):
            raise parser.error('Range provided for kstar2 invalid')
    return args


##################################################################################
# BEGIN MAIN FUNCTION
##################################################################################
if __name__ == '__main__':

    # LOOP OVER GALAXIES IN SAMPLE
    ###########################################################################
    def _gx_realization(gx, n_systems, fixed_pop, dat_list, gx_component, LISA_calc):
        np.random.seed(gx)
        PSD = pd.DataFrame(columns=['freq', 'psd'])
        SNR = pd.DataFrame(columns=['gw_freq', 'SNR'])
        
        if len(dat_list) == 3:
            dat_kde = np.vstack([fixed_pop.mass_1, fixed_pop.mass_2, np.log10(fixed_pop.porb)])
        else:
            dat_kde = np.vstack([fixed_pop.mass_1, fixed_pop.mass_2, np.log10(fixed_pop.porb), ss.logit(fixed_pop.ecc)])
        bw = utils.knuth_bw_selector(dat_kde)
        dat_kernel = stats.gaussian_kde(dat_kde, bw_method=bw)
        # CHUNK UP SAMPLE IF THERE ARE A LOT OF SYSTEMS IN THE POPULATION
        ###########################################################################
        if n_systems > 1e5:
            nLoop = int(n_systems/1.0e5)
            for ii in range(nLoop):
                nSample = int(n_systems/float(nLoop))
                # FIRST SAMPLE THE BINARY PARAMETERS FROM THE FIXED POPULATION
                # BY GENERATING A KDE FIT
                #####################################################################
                binary_sample_dat = dat_kernel.resample(nSample)
                if len(dat_list) == 3:
                    binary_sample_dat[2,:] = 10**binary_sample_dat[2,:]
                    binary_sample_dat = np.vstack([binary_sample_dat, np.zeros(nSample)])
                else:
                    #convert the orbital period out of log-space and 
                    #eccentricity out of logit space
                    binary_sample_dat[2,:] = 10**binary_sample_dat[2,:]
                    binary_sample_dat[3,:] = ss.expit(binary_sample_dat[3,:])
                    binary_sample_dat = np.vstack([binary_sample_dat, np.zeros(nSample)])
                # NEXT SAMPLE THE BINARY POSITIONS AND ORIENTATIONS
                #####################################################################
                binary_sample_positions = MC_sample.galactic_position_sample(gx_component, 
                                                                             size = nSample, 
                                                                             model='McMillan')
                
                full_sample = np.concatenate([binary_sample_dat,binary_sample_positions]).T
                full_sample = pd.DataFrame(full_sample,\
                                           columns = ['mass1', 'mass2', 'porb', 'ecc',
                                                      'xGx', 'yGx', 'zGx', 'dist',
                                                      'inc', 'OMEGA', 'omega'])
                full_sample.to_hdf('gx_real_'+str(gx)+'_'+gx_component+'_'+
                                   kstar1_range_string+'_'+kstar2_range_string+'.h5',
                                   key='gx', append='True')
                
                
                # NOW WE CAN COMPUTE THE PSD AND SNRs OF THE POPULATION
                #####################################################################
                if LISA_calc:
                    SNR_dat, psd_dat = GW_calcs.LISA_calcs(full_sample.mass1*Msun, full_sample.mass2*Msun,
                                                           full_sample.porb*sec_in_year,
                                                           full_sample.ecc, full_sample.dist*1000*parsec,
                                                           150)
                    if SNR_dat.shape[0] > 5:
                        SNR = SNR.append(SNR_dat)
                    PSD = PSD.append(psd_dat)
        else:
            nSample = n_systems
         
            # FIRST SAMPLE THE BINARY PARAMETERS FROM THE FIXED POPULATION
            # BY GENERATING A KDE FIT
            #####################################################################
            binary_sample_dat = dat_kernel.resample(nSample)
            if len(dat_list) == 3:
                binary_sample_dat[2,:] = 10**binary_sample_dat[2,:]
                binary_sample_dat = np.vstack([binary_sample_dat, np.zeros(nSample)])
            else:
                #convert the orbital period out of log-space and 
                #eccentricity out of logit space
                binary_sample_dat[2,:] = 10**binary_sample_dat[2,:]
                binary_sample_dat[3,:] = ss.expit(binary_sample_dat[3,:])
                binary_sample_dat = np.vstack([binary_sample_dat, np.zeros(nSample)])

            # NEXT SAMPLE THE BINARY POSITIONS AND ORIENTATIONS
            #####################################################################
            binary_sample_positions = MC_sample.galactic_position_sample(gx_component, 
                                                                         size = nSample, 
                                                                         model='McMillan')
            full_sample = np.concatenate([binary_sample_dat,binary_sample_positions]).T
            full_sample = pd.DataFrame(full_sample,
                                       columns = ['mass1', 'mass2', 'porb', 'ecc',
                                                  'xGx', 'yGx', 'zGx', 'dist',
                                                  'inc', 'OMEGA', 'omega'])

            full_sample.to_hdf('gx_real_'+str(gx)+'_'+gx_component+'_'+
                               kstar1_range_string+'_'+kstar2_range_string+'.h5', key='gx', append='True')
            # NOW WE CAN COMPUTE THE PSD OF THE POPULATION
            #####################################################################
            if LISA_calc:
                SNR_dat, psd_dat = GW_calcs.LISA_calcs(full_sample.mass1*Msun, full_sample.mass2*Msun,
                                                       full_sample.porb*sec_in_year,
                                                       full_sample.ecc, full_sample.dist*1000*parsec,
                                                       150)
                
                
                SNR = SNR.append(SNR_dat)
                PSD = PSD.append(psd_dat)  
        
        if LISA_calc:
            SNR.to_hdf('gx_real_'+str(gx)+'_'+gx_component+'_'+kstar1_range_string+
                   '_'+kstar2_range_string+'.h5', key='SNR', append='True')            
            PSD.to_hdf('gx_real_'+str(gx)+'_'+gx_component+'_'+kstar1_range_string+
                   '_'+kstar2_range_string+'.h5', key='PSD', append='True')      
            
        return

    # READ COMMANDLINE ARGUMENTS
    ##############################################################################
    args = parse_commandline()

    # CONSTANTS
    ##############################################################################
    G = 6.67384*math.pow(10, -11.0)
    c = 2.99792458*math.pow(10, 8.0)
    parsec = 3.08567758*math.pow(10, 16)
    Rsun = 6.955*math.pow(10, 8)
    Msun = 1.9891*math.pow(10,30)
    day = 86400.0
    rsun_in_au = 215.0954
    day_in_year = 365.242
    sec_in_day = 86400.0
    sec_in_hour = 3600.0
    hrs_in_day = 24.0
    sec_in_year = 3.15569*10**7.0
    Tobs = 4 * sec_in_year
    geo_mass = G/c**2

    # Handle the file structure for different final kstars
    ###########################################################################
    if len(args.final_kstar1) == 2:
        kstar1_range = np.arange(args.final_kstar1[0], args.final_kstar1[1])
        kstar1_range_string = str(int(args.final_kstar1[0]))+'_'+str(int(args.final_kstar1[1]))
    else:
        kstar1_range = args.final_kstar1
        kstar1_range_string = str(int(args.final_kstar1[0]))
    
    if len(args.final_kstar2) == 2:
        kstar2_range = np.arange(args.final_kstar2[0], args.final_kstar2[1])
        kstar2_range_string = str(int(args.final_kstar2[0]))+'_'+str(int(args.final_kstar2[1]))
    else:
        kstar2_range = args.final_kstar2
        kstar2_range_string = str(int(args.final_kstar2[0]))

    # READ IN DATA
    ###########################################################################
    dat_path = '../COSMIC_paper_data/data/dat_'+args.galaxy_component+'_'+\
                kstar1_range_string+'_'+kstar2_range_string+'.h5'
    total_sampled_mass = np.max(pd.read_hdf(dat_path, key='totalMass'))
    fixed_pop = pd.read_hdf(dat_path, key='bcm') 
    bpp = pd.read_hdf(dat_path, key='bpp')

    # Filter out systems which undergo Common Envelope w/ HG star secondary
    ###########################################################################
    if args.HG_save != True:
        comenv_index, = np.where(bpp.evol_type==7.0)
        bpp_pre_ce = bpp.iloc[comenv_index-1]
        bpp_ce_save = bpp_pre_ce.loc[bpp_pre_ce.kstar_2 != 2.0]
        bpp_ce_save = bpp_ce_save.loc[bpp_ce_save.kstar_2 != 8.0]
        index_save = bpp_ce_save.index

        fixed_pop = fixed_pop.loc[fixed_pop.index.isin(index_save)]

    if fixed_pop.ecc.all() <= 1e-3:
        dat_list = ['mass_1', 'mass_2', 'porb']
    else:
        dat_list = ['mass_1', 'mass_2', 'porb', 'ecc']
    
    # Filter out long period binaries
    ###########################################################################
    fixed_pop = fixed_pop.loc[fixed_pop.porb < 1]
    
    # SAMPLE THE BINARY PARAMETERS AND GALACTIC POSITIONS
    ###########################################################################
    component_mass = MC_sample.select_component_mass(args.galaxy_component)
    nSystems = MC_sample.mass_weighted_number(fixed_pop, total_sampled_mass, component_mass)

    if args.nproc > 1:
        n_loops = args.N_realizations / args.nproc
        for n in range(n_loops):
            output = mp.Queue()
            processes = [mp.Process(target = _gx_realization,\
                                    args = (x + n*args.nproc + 0, nSystems, fixed_pop, dat_list, args.galaxy_component, args.LISA_calc)) for x in range(args.nproc)]
            
            for p in processes:
                p.daemon = True
                p.start()
            
            for p in processes:
                p.join()
    else:
        n_loops = args.N_realizations
        for n in range(n_loops):
            _gx_realization(n, nSystems, fixed_pop, dat_list, args.galaxy_component, args.LISA_calc)

    print'All done friend!'
